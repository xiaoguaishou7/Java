#类、方法和变量修饰符:
abstract	    声明抽象
class	        类
extends	      扩充,继承
final	        最终值,不可改变的
implements	  实现（接口）
interface	    接口
native	      本地，原生方法（非 Java 实现）
new	          新,创建
static	      静态
strictfp	    严格,精准
synchronized	线程,同步
transient	    短暂
volatile	    易失

#错误处理:
assert	断言表达式是否为真
catch	  捕捉异常
finally	有没有异常都执行
throw	  抛出一个异常对象
throws	声明一个异常可能被抛出
try	    捕获异常

#基本类型:
boolean	布尔型
byte	  字节型
char	  字符型
double	双精度浮点
float	  单精度浮点
int	    整型
long	  长整型
short	  短整型

#变量引用:
super	父类,超类
this	本类
void	无返回值

#构造方法
每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。

在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

下面是一个构造方法示例：

public class Puppy{
    public Puppy(){
    }
 
    public Puppy(String name){
        // 这个构造器仅有一个参数：name
    }
}

#创建对象
对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：

声明：声明一个对象，包括对象名称和对象类型。
实例化：使用关键字 new 来创建一个对象。
初始化：使用 new 创建对象时，会调用构造方法初始化对象。

#类型转化
低  ------------------------------------>  高
byte,short,char—> int —> long—> float —> double 
自动类型转换：
必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。

强制类型转换：
转换过程中可能导致溢出或损失精度，例如：

int i =128;   
byte b = (byte)i;
因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。

#Java变量类型
Java语言支持的变量类型有：

类变量：独立于方法之外的变量，用 static 修饰。  //类变量就是说它可以不通过对象来访问，可以直接访问
实例变量：独立于方法之外的变量，不过没有 static 修饰。
局部变量：类的方法中的变量。
例子：
public class Variable{
    static int allClicks=0;    // 类变量
 
    String str="hello world";  // 实例变量
 
    public void method(){
 
        int i = 0;  // 局部变量
 
    }
}

#Java 修饰符

Java语言提供了很多修饰符，主要分为以下两类：
1.访问修饰符
2.非访问修饰符

1.访问控制修饰符
Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）私有访问修饰符是最严格
的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private

public : 对所有类可见。使用对象：类、接口、变量、方法

protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。

请注意以下方法继承的规则：

父类中声明为 public 的方法在子类中也必须为 public。

父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。

父类中声明为 private 的方法，不能够被子类继承。

2.非访问控制修饰符

为了实现一些其他的功能，Java 也提供了许多非访问修饰符。

static 修饰符，用来修饰类方法和类变量。 局部变量不能被声明为 static 变量。

final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

abstract 修饰符，用来创建抽象类和抽象方法。

1.抽象类：
抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。
一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。
抽象类可以包含抽象方法和非抽象方法。

2.抽象方法：
抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。
抽象方法不能被声明成 final 和 static。
任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。
如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。
抽象方法的声明以分号结尾，例如：public abstract sample();。

synchronized 和 volatile 修饰符，主要用于线程的编程。

位运算：
操作符	 描述	                                                                             例子
＆	   如果相对应位都是1，则结果为1，否则为0	                                            （A＆B），得到12，即0000 1100
|	    如果相对应位都是 0，则结果为 0，否则为 1	                                         （A | B）得到61，即 0011 1101
^	    如果相对应位值相同，则结果为0，否则为1	                                        （A ^ B）得到49，即 0011 0001
〜	   按位取反运算符翻转操作数的每一位，即0变成1，1变成0。	                              （〜A）得到-61，即1100 0011
<< 	    按位左移运算符。左操作数按位左移右操作数指定的位数。	                              A << 2得到240，即 1111 0000
>> 	    按位右移运算符。左操作数按位右移右操作数指定的位数。	                              A >> 2得到15即 1111
>>> 	按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。	A>>>2得到15即0000 1111

Java String 类：
String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：

String s1 = "Runoob";              // String 直接创建
String s2 = "Runoob";              // String 直接创建
String s3 = s1;                    // 相同引用
String s4 = new String("Runoob");   // String 对象创建
String s5 = new String("Runoob");   // String 对象创建

连接字符串：
更常用的是使用'+'操作符来连接字符串，如：
"Hello," + " runoob" + "!"
结果如下:

"Hello, runoob!"

Java 数组：
1.声明数组变量 //声明数组并不是创建数组
首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：
dataType[] arrayRefVar;   // 首选的方法，dataType是数据类型
或
dataType arrayRefVar[];  // 效果相同，但不是首选方法，这个东西不怎么用，好像是会出现什么线程之类问题

2.创建数组
Java语言使用new操作符来创建数组，语法如下：
arrayRefVar = new dataType[arraySize];

上面的语法语句做了两件事：
一、使用 dataType[arraySize] 创建了一个数组。
二、把新创建的数组的引用赋值给变量 arrayRefVar。

数组变量的声明，和创建数组可以用一条语句完成，如下所示：
dataType[] arrayRefVar = new dataType[arraySize];

3.For-Each 循环
JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。

语法格式如下：

for(type element: array)
{
    System.out.println(element);
}

实例
该实例用来显示数组 myList 中的所有元素：

TestArray.java 文件代码：
public class TestArray {
   public static void main(String[] args) {
      double[] myList = {1.9, 2.9, 3.4, 3.5};
 
      // 打印所有数组元素
      for (double element: myList) {
         System.out.println(element);
      }
   }
}
输出：
1.9
2.9
3.4
3.5

4.数组作为函数的参数
数组可以作为参数传递给方法。

例如，下面的例子就是一个打印 int 数组中元素的方法:

public static void printArray(int[] array) {
  for (int i = 0; i < array.length; i++) {
    System.out.print(array[i] + " ");
  }
}
下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：
printArray(new int[]{3, 1, 2, 6, 4, 2});

5.数组作为函数的返回值
public static int[] reverse(int[] list) { //同时也是数组作为函数的参数
  int[] result = new int[list.length];
 
  for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {
    result[j] = list[i];
  }
  return result;
}















